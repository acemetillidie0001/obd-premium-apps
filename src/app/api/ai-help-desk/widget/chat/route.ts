/**
 * Widget Chat API Route
 * 
 * Public endpoint for widget chat requests.
 * Validates widget key and proxies to AnythingLLM.
 */

import { NextRequest } from "next/server";
import { validationErrorResponse } from "@/lib/api/validationError";
import { handleApiError, apiSuccessResponse, apiErrorResponse } from "@/lib/api/errorHandler";
import { validateWidgetKey } from "@/lib/api/widgetAuth";
import { checkWidgetRateLimit } from "@/lib/api/widgetRateLimit";
import { getWorkspaceSlugForBusiness } from "@/lib/integrations/anythingllm/scoping";
import { chatWorkspace } from "@/lib/integrations/anythingllm/client";
import { upsertContactFromExternalSource, addActivityNote } from "@/lib/apps/obd-crm/crmService";
import { z } from "zod";
import type { ChatRequest, ChatResponse } from "@/lib/apps/ai-help-desk/types";

export const runtime = "nodejs";

// Zod schema for request validation
const widgetChatRequestSchema = z.object({
  businessId: z.string().min(1, "Business ID is required"),
  key: z.string().min(1, "Widget key is required"),
  message: z.string().min(1, "Message is required").max(2000, "Message is too long"),
  threadId: z.string().optional(),
  // Optional contact fields for CRM integration (future extensibility)
  customerName: z.string().optional(),
  customerEmail: z.union([z.string().email(), z.literal("")]).optional(),
  customerPhone: z.string().optional(),
});

export async function POST(request: NextRequest) {
  // Block demo mode mutations (read-only)
  const { assertNotDemoRequest } = await import("@/lib/demo/assert-not-demo");
  const demoBlock = assertNotDemoRequest(request);
  if (demoBlock) return demoBlock;

  try {
    // Parse and validate request body
    const body = await request.json();
    const validationResult = widgetChatRequestSchema.safeParse(body);

    if (!validationResult.success) {
      return validationErrorResponse(validationResult.error);
    }

    const { businessId, key, message, threadId, customerName, customerEmail, customerPhone } = validationResult.data;

    // Validate widget key
    const isValid = await validateWidgetKey(businessId.trim(), key);
    if (!isValid) {
      return apiErrorResponse(
        "Invalid widget key",
        "UNAUTHORIZED",
        403
      );
    }

    // Check rate limit
    const rateLimitResponse = checkWidgetRateLimit(request, businessId.trim());
    if (rateLimitResponse) {
      return rateLimitResponse;
    }

    // Get workspace slug for business
    const workspaceResult = await getWorkspaceSlugForBusiness(businessId.trim());
    const workspaceSlug = workspaceResult.workspaceSlug;

    // Perform chat via AnythingLLM
    const chatResponse = await chatWorkspace(workspaceSlug, message, threadId);

    // Best-effort CRM integration when ticket is created (first message, no threadId)
    // Only integrate on first message to avoid duplicate contacts for same conversation
    const isTicketCreation = !threadId;
    if (isTicketCreation) {
      try {
        const name = customerName?.trim() || null;
        const email = customerEmail?.trim() || null;
        const phone = customerPhone?.trim() || null;

        // Skip CRM if name missing OR (email and phone both missing)
        if (!name || (!email && !phone)) {
          if (process.env.NODE_ENV !== "production") {
            console.log(`[CRM Integration] Skipping contact upsert for help desk ticket: missing name or identifiers`);
          }
        } else {
          // Create ticket title/summary from message (max 200 chars)
          const ticketTitle = message.trim().substring(0, 200);
          // Get threadId from response (it's generated by AnythingLLM on first message)
          const newThreadId = chatResponse.threadId;

          // Upsert contact
          const contact = await upsertContactFromExternalSource({
            businessId: businessId.trim(),
            source: "helpdesk",
            name,
            email: email || null,
            phone: phone || null,
            tagNames: ["Support", "Help Desk"],
          });

          // Build activity note
          let noteText = `Help Desk ticket created: ${ticketTitle}`;
          if (newThreadId) {
            noteText += ` (Ticket: ${newThreadId})`;
          }

          await addActivityNote({
            businessId: businessId.trim(),
            contactId: contact.id,
            note: noteText,
          });
        }
      } catch (crmError) {
        // Log error but don't fail the chat request (best-effort integration)
        if (process.env.NODE_ENV !== "production") {
          console.error(`[CRM Integration] Failed to sync contact for help desk ticket:`, crmError);
        }
      }
    }

    // Return normalized response
    const response: ChatResponse = {
      ok: true,
      data: {
        threadId: chatResponse.threadId,
        answer: chatResponse.answer,
        sources: chatResponse.sources,
      },
    };

    return apiSuccessResponse(response.data);
  } catch (error) {
    return handleApiError(error);
  }
}

